#!/usr/bin/python3

# This is neural2d-gui.py - an optional GUI controller for the neural2d program.
# David R. Miller, 2014, dave@millermattson.com


"""
To do:

"""

from __future__ import with_statement
import sys
from PyQt4 import QtCore
from PyQt4.QtCore import SIGNAL
from PyQt4 import QtGui
from PyQt4.QtCore import Qt
from qtui import Ui_neuralNetController
import subprocess
import atexit
import os
import signal
import time
import threading

# The path and filename for the named pipe must match whatever path
# and filename used in the neural net program:

out_file = 0
filename = "neural2d-command-"   # works for Linux


def killSpawn(child, file, filename):
    print("Deleting " + filename)
    file.close()
    os.remove(filename)
    
    if child.poll() == None:
        print("Killing pid %d" % (child.pid))
        os.killpg(os.getpgid(child.pid), signal.SIGTERM)   # 15 = SIGTERM


class MainWindow(QtGui.QMainWindow, Ui_neuralNetController, QtCore.QObject):
    """
    GUI controller. Contains the customization for Qt Designer created window.
    """
    def __init__(self, parent = None):
        super(MainWindow, self).__init__(parent)
        
        self.setupUi(self)  # call the function generated by pyuic4
        
        # Initialize widgets to sane starting values:
        self.initUIFields()

        # Connect the signals
        C = QtCore.QObject.connect
        
        C(self.btn_startNet, SIGNAL("clicked()"),
                 lambda: self.startNet())

        C(self.btn_training, SIGNAL("clicked()"),
                 lambda: self.setTrainingMode())
        C(self.btn_validate, SIGNAL("clicked()"),
                 lambda: self.setValidateMode())
        C(self.btn_trained, SIGNAL("clicked()"),
                 lambda: self.setTrainedMode())
        
        C(self.txt_topologyFilename, SIGNAL("editingFinished()"),
                 lambda: self.topologyFileChanged())
        C(self.txt_trainDataFilename, SIGNAL("editingFinished()"),
                 lambda: self.trainDataFileChanged())
        C(self.txt_weightsFilename, SIGNAL("editingFinished()"),
                 lambda: self.weightsFileChanged())
        
        C(self.btn_selectTopologyFile, SIGNAL("clicked()"),
                 lambda: self.selectTopologyFile())
        C(self.btn_selectTrainDataFile, SIGNAL("clicked()"),
                 lambda: self.selectTrainDataFile())
        C(self.btn_selectWeightsFile, SIGNAL("clicked()"),
                 lambda: self.selectWeightsFile())
        
        C(self.btn_runOnce, SIGNAL("clicked()"),
                 lambda: self.selectRunOnce())
        C(self.btn_repeat, SIGNAL("clicked()"),
                 lambda: self.selectRunRepeat())
        C(self.btn_shuffleRepeat, SIGNAL("clicked()"),
                 lambda: self.selectShuffleRepeat())

        C(self.btn_reloadData, SIGNAL("clicked()"),
                 lambda: self.reloadInputSamples())
        
        C(self.txt_everyNth, SIGNAL("editingFinished()"),
                 lambda: self.everyNthChanged(self.txt_everyNth.text()))
        C(self.txt_errorAverageWindow, SIGNAL("editingFinished()"),
                 lambda: self.errorAverageWindowChanged(self.txt_errorAverageWindow.text()))
        
        C(self.txt_eta, SIGNAL("editingFinished()"),
                 lambda: self.etaChanged(self.txt_eta.text()))
        C(self.checkBox_train, SIGNAL("stateChanged(int)"),
                 lambda: self.setTrainingEnable())
        C(self.checkBox_dynamicEta, SIGNAL("stateChanged(int)"),
                 lambda: self.dynamicEtaChanged())
        
        C(self.txt_alpha, SIGNAL("editingFinished()"),
                 lambda: self.alphaChanged(self.txt_alpha.text()))
        C(self.txt_lambda, SIGNAL("editingFinished()"),
                 lambda: self.lambdaChanged(self.txt_lambda.text()))
        
        C(self.txt_doneThreshold, SIGNAL("editingFinished()"),
                 lambda: self.doneThresholdChanged(self.txt_doneThreshold.text()))
        C(self.btn_loadWeights, SIGNAL("clicked()"),
                 lambda: self.loadWeights(self.txt_weightsFilename.text()))
        C(self.btn_saveWeights, SIGNAL("clicked()"),
                 lambda: self.saveWeights(self.txt_weightsFilename.text()))
        
        C(self.btn_pause, SIGNAL("clicked()"),
                 lambda: self.pause())
        C(self.btn_resume, SIGNAL("clicked()"),
                 lambda: self.resume())
        
        self.actionAbout.triggered.connect(self.menuAboutClicked)
        
        #signal.signal(signal.SIGCHLD, self.sigchild_handler)  # not reliable
        
    def checkChildTermination(self, proc):
        while True:
            print("calling proc.wait() on pid %d" % (proc.pid))
            proc.wait()
            print("child exited")
            self.childTerminated()
            break

    def childTerminated(self):
        # To do: remember the prior settings and restore those
        out_file = 0
        filename = "neural2d-command-"   # works for Linux
        print("Neural net child process exited.")
        
        self.btn_startNet.setEnabled(True)
        
        self.txt_topologyFilename.setEnabled(True)
        self.btn_selectTopologyFile.setEnabled(True)
        
        self.txt_trainDataFilename.setEnabled(True)
        self.btn_selectTrainDataFile.setEnabled(True)
        
        self.btn_training.setEnabled(False)
        self.btn_validate.setEnabled(False)
        self.btn_trained.setEnabled(False)
        
        self.btn_runOnce.setEnabled(False)
        self.btn_repeat.setEnabled(False)
        self.btn_shuffleRepeat.setEnabled(False)
        self.btn_reloadData.setEnabled(False)
        
        self.txt_everyNth.setEnabled(False)
        self.txt_errorAverageWindow.setEnabled(False)
        self.txt_eta.setEnabled(False)
        self.checkBox_train.setEnabled(False)
        self.checkBox_dynamicEta.setEnabled(False)
        self.txt_alpha.setEnabled(False)
        self.txt_lambda.setEnabled(False)
        self.txt_doneThreshold.setEnabled(False)
        self.btn_saveWeights.setEnabled(False)
        self.btn_loadWeights.setEnabled(False)
        
        self.btn_pause.setEnabled(False)
        self.btn_resume.setEnabled(False)

    def menuAboutClicked(self):
        about_box = QtGui.QMessageBox(self)
        about_box.about(self, 'About', \
                '''\
This is neural2d-gui.py,
by dave@millermattson.com,\nhttp://millermattson.com/dave

This is a GUI for the neural2d neural net simulator.
It is optional; the neural2d program can be run as a standalone
console program.

Quick start:

Press the Start Net button to invoke the neural net simulator. Choose
TRAINING, VALIDATE, or TRAINED mode, tweak the parameter as desired,
then press Resume to run the simulator.

The simulation will pause when the Pause button is pressed, or when the
recent average network error falls below the Done error threshold. You
can then press the Save weights button to save all the connection weights
to use later.

More info:

The topology config file contains lines like these:

     input size 32x32
     layer1 from input size 16x16
     output from layer1 size 1x5

The input data config file contains lines like these:

     imagefile-1.bmp  1.0 0.0 0.0 0.0 0.0
     imagefile-2.bmp  -1.0 0.5 0.25 0.5 1.0
     
The target output values are required for TRAINING and VALIDATE modes, optional otherwise.

The three modes of operation are:

     TRAINING - weights are updated, outputs and accuracy are reported
     VALIDATE - weights are not updated, outputs and accuracy are reported
     TRAINED - weights are not updated, output values only are reported

For more information, see the tutorial video.
''')


    def topologyFileChanged(self):
        return
    
    def trainDataFileChanged(self):
        if self.lastInputDataFilename != self.txt_trainDataFilename.text():
            self.btn_reloadData.setEnabled(True)
            self.lastInputDataFilename = self.txt_trainDataFilename.text()
    
    def weightsFileChanged(self):
        return

        
    def selectTopologyFile(self):
        filename = QtGui.QFileDialog.getOpenFileName(self,
                        'Topology config file', '', "Config files (*.txt);;All files (*.*)")
        self.txt_topologyFilename.setText(filename)
        
    def selectTrainDataFile(self):
        filename = QtGui.QFileDialog.getOpenFileName(self,
                        'Input data config file', '', "Config files (*.txt);;All files (*.*)")
        self.txt_trainDataFilename.setText(filename)
        # When the input data field changes, allow the user to reload the data:
        if self.lastInputDataFilename != self.txt_trainDataFilename.text():
            self.btn_reloadData.setEnabled(True)
            self.lastInputDataFilename = self.txt_trainDataFilename.text()
                
    def selectWeightsFile(self):
        filename = QtGui.QFileDialog.getOpenFileName(self,
                        'Weights file', '', "Text files (*.txt);;All files (*.*)")
        self.txt_weightsFilename.setText(filename)
    
    
    def setTrainingMode(self):
        self.btn_shuffleRepeat.setChecked(True)
        
        self.txt_everyNth.setText("150")
        
        self.txt_errorAverageWindow.setText("150")
        self.txt_errorAverageWindow.setEnabled(True)
        
        self.txt_eta.setText("0.1")
        self.txt_eta.setEnabled(True)
        
        self.checkBox_train.setChecked(True)
        self.checkBox_train.setEnabled(True)
        
        self.checkBox_dynamicEta.setChecked(True)
        self.checkBox_dynamicEta.setEnabled(True)
        
        self.txt_alpha.setText("0.1")
        self.txt_alpha.setEnabled(True)
        
        self.txt_lambda.setText("0.0")
        self.txt_lambda.setEnabled(True)
        
        self.txt_doneThreshold.setText("0.01")
        self.txt_doneThreshold.setEnabled(True)
    
    def setValidateMode(self):
        self.btn_runOnce.setChecked(True)
        
        self.txt_everyNth.setText("1")
        
        self.txt_errorAverageWindow.setText("10")
        self.txt_errorAverageWindow.setEnabled(True)
        
        self.txt_eta.setText("0.1")
        self.txt_eta.setEnabled(False)
        
        self.checkBox_train.setChecked(False)
        self.checkBox_train.setEnabled(False)
        
        self.checkBox_dynamicEta.setChecked(False)
        self.checkBox_dynamicEta.setEnabled(False)
        
        self.txt_alpha.setText("0.1")
        self.txt_alpha.setEnabled(False)
        
        self.txt_lambda.setText("0.0")
        self.txt_lambda.setEnabled(False)
        
        self.txt_doneThreshold.setText("0.01")
        self.txt_doneThreshold.setEnabled(False)
    
    def setTrainedMode(self):
        self.btn_runOnce.setChecked(True)
        
        self.txt_everyNth.setText("1")
        
        self.txt_errorAverageWindow.setText("1")
        self.txt_errorAverageWindow.setEnabled(False)
        
        self.txt_eta.setText("0.1")
        self.txt_eta.setEnabled(False)
        
        self.checkBox_train.setChecked(False)
        self.checkBox_train.setEnabled(False)
        
        self.checkBox_dynamicEta.setChecked(False)
        self.checkBox_dynamicEta.setEnabled(False)
        
        self.txt_alpha.setText("0.1")
        self.txt_alpha.setEnabled(False)
        
        self.txt_lambda.setText("0.0")
        self.txt_lambda.setEnabled(False)
        
        self.txt_doneThreshold.setText("0.01")
        self.txt_doneThreshold.setEnabled(False)
        

    # Launch the neural net executable. It must run asynchronously.
    # This is OS-dependent. A Linux version is shown below using subprocess.Popen() that
    # opens the application in an xterm window. If you can't figure out how to launch the
    # neural net program in the background on your OS, you can just start the neural net
    # program manually. Launching it here is just a convenience.

    def startNet(self):
        global out_file
        
        print("START NET with: " + "./neural2d " + self.txt_topologyFilename.text())
        
        # This works for Linux:
        proc = subprocess.Popen(["xterm", 
                         "-e", "./neural2d", 
                         self.txt_topologyFilename.text(),
                         self.txt_trainDataFilename.text(),
                         self.txt_weightsFilename.text()
                         ], preexec_fn=os.setsid)
        print("proc.pid = %d" % (proc.pid))  # pid of the spawned xterm shell
        
        # Watch for the spawned process to exit:
        thread = threading.Thread(target=self.checkChildTermination, args=(proc,) )
        thread.daemon = True
        thread.start()
        
        # Open the command interface file:
        filename = "neural2d-command-" + str(proc.pid)
        out_file = open(filename, "w+", buffering=1)

        # Remember the spawned function pid:
        print("Registering atexit") # !!!
        atexit.register(killSpawn, child=proc, file=out_file, filename=filename)

        # Enable/disable some widgets:
        self.txt_topologyFilename.setEnabled(False)
        self.btn_selectTopologyFile.setEnabled(False)
        
        self.txt_trainDataFilename.setEnabled(True)
        self.btn_selectTrainDataFile.setEnabled(True)
        
        self.btn_training.setEnabled(True)
        self.btn_validate.setEnabled(True)
        self.btn_trained.setEnabled(True)
        
        self.btn_runOnce.setEnabled(True)
        self.btn_repeat.setEnabled(True)
        self.btn_shuffleRepeat.setEnabled(True)
        self.btn_reloadData.setEnabled(False)
        
        self.txt_everyNth.setEnabled(True)
        self.txt_errorAverageWindow.setEnabled(True)
        
        self.txt_eta.setEnabled(True)
        self.checkBox_train.setEnabled(True)
        self.checkBox_dynamicEta.setEnabled(True)
        
        self.txt_alpha.setEnabled(True)
        self.txt_lambda.setEnabled(True)
        
        self.txt_doneThreshold.setEnabled(True)
        self.btn_saveWeights.setEnabled(True)
        self.btn_loadWeights.setEnabled(True)
        
        self.btn_startNet.setEnabled(False)
        self.btn_pause.setEnabled(False)
        self.btn_resume.setEnabled(True)


    def selectRunOnce(self):
        if out_file:
            out_file.write("repeat False\n")

    def selectRunRepeat(self):
        if out_file:
            out_file.write("repeat True\n")
            out_file.write("shuffle False\n")
    
    def selectShuffleRepeat(self):
        if out_file:
            out_file.write("repeat True\n")
            out_file.write("shuffle True\n")
    
    
    def reloadInputSamples(self):
        print("Not yet implemented, sorry.")
        self.btn_reloadData.setEnabled(False)
        return


    def loadWeights(self, filename):
        print("Load weights from " + filename)
        if out_file:
            out_file.write("load " + filename + "\n")

    def saveWeights(self, filename):
        print("Save weights in " + filename)
        if out_file:
            out_file.write("save " + filename + "\n")

    def setTrainingEnable(self):
        flag = self.checkBox_train.isChecked()
        print("set train enable=" + str(flag))
        if out_file:
            out_file.write("train " + str(flag) + "\n")

    def pause(self):
        print("pause")
        if out_file:
            out_file.write("pause\n")
        self.btn_resume.setEnabled(True)
        self.btn_pause.setEnabled(False)
        self.btn_training.setEnabled(True)
        self.btn_validate.setEnabled(True)
        self.btn_trained.setEnabled(True)

    def resume(self):
        print("resume")
        flag = self.checkBox_train.isChecked()
        if out_file:
            out_file.write("train " + str(flag) + "\n")

        val = self.txt_everyNth.text()
        if out_file:
            out_file.write("report " + str(val) + "\n")

        val = self.txt_errorAverageWindow.text()
        if out_file:
            out_file.write("averageover " + str(val) + "\n")

        val = self.txt_eta.text()
        if out_file:
            out_file.write("eta " + str(val) + "\n")

        flag = self.checkBox_dynamicEta.isChecked()
        if out_file:
            out_file.write("dynamiceta " + str(flag) + "\n")

        val = self.txt_alpha.text()
        if out_file:
            out_file.write("alpha " + str(val) + "\n")
        
        val = self.txt_lambda.text()
        if out_file:
            out_file.write("lambda " + str(val) + "\n")

        val = self.btn_runOnce.isChecked()
        if val and out_file:
            out_file.write("repeat False\n")
            
        val = self.btn_repeat.isChecked()
        if val and out_file:
            out_file.write("repeat True\n")
            out_file.write("shuffle False\n")

        val = self.btn_shuffleRepeat.isChecked()
        if val and out_file:
            out_file.write("repeat True\n")
            out_file.write("shuffle True\n")

        val = self.txt_doneThreshold.text()
        if out_file:
            out_file.write("doneErrorThreshold" + str(val) + "\n")

        if out_file:
            out_file.write("resume\n")

        self.btn_resume.setEnabled(False)
        self.btn_pause.setEnabled(True)
        self.btn_training.setEnabled(False)
        self.btn_validate.setEnabled(False)
        self.btn_trained.setEnabled(False)

    def everyNthChanged(self, val):
        print("report " + str(val))
        out_file.write("report " + str(val) + "\n")

    def errorAverageWindowChanged(self, val):
        print("averaging window " + str(val))
        if out_file:
            out_file.write("averageover " + str(val) + "\n")

    def etaChanged(self, val):
        print("eta " + str(val))
        if out_file:
            out_file.write("eta " + str(val) + "\n")
        
    def dynamicEtaChanged(self):
        flag = self.checkBox_dynamicEta.isChecked()
        print("set dynamicEta=" + str(flag))
        out_file.write("dynamiceta " + str(flag) + "\n")

    def alphaChanged(self, val):
        print("alpha " + str(val))
        if out_file:
            out_file.write("alpha " + str(val) + "\n")
        
    def lambdaChanged(self, val):
        print("lambda " + str(val))
        if out_file:
            out_file.write("lambda " + str(val) + "\n")
        
    def doneThresholdChanged(self, val):
        return

    def initUIFields(self):
        """Set the GUI widgets to their starting values and states"""
        self.txt_topologyFilename.setText("topology.txt")
        self.btn_selectTopologyFile.setEnabled(True)

        self.txt_trainDataFilename.setText("inputData.txt")
        self.btn_selectTrainDataFile.setEnabled(True)
        self.lastInputDataFilename = self.txt_trainDataFilename.text()

        self.txt_weightsFilename.setText("weights.txt")
        
        self.btn_training.setEnabled(False)
        self.btn_validate.setEnabled(False)
        self.btn_trained.setEnabled(False)
        
        self.btn_runOnce.setEnabled(False)
        self.btn_repeat.setEnabled(False)
        self.btn_shuffleRepeat.setChecked(True)
        self.btn_shuffleRepeat.setEnabled(False)
        self.btn_reloadData.setEnabled(False)
        
        self.txt_everyNth.setText("45")
        self.txt_everyNth.setEnabled(False)
        self.txt_errorAverageWindow.setText("100")
        self.txt_errorAverageWindow.setEnabled(False)
        
        self.txt_eta.setText("0.001")
        self.txt_eta.setEnabled(False)
        self.checkBox_train.setChecked(True)
        self.checkBox_train.setEnabled(False)
        self.checkBox_dynamicEta.setChecked(True)
        self.checkBox_dynamicEta.setEnabled(False)
        
        self.txt_alpha.setText("0.001")
        self.txt_alpha.setEnabled(False)
        self.txt_lambda.setText("0.0")
        self.txt_lambda.setEnabled(False)
        
        self.txt_doneThreshold.setText("0.01")
        self.txt_doneThreshold.setEnabled(False)
        
        self.btn_pause.setEnabled(False)
        self.btn_resume.setEnabled(False)
        self.btn_saveWeights.setEnabled(False)
        self.btn_loadWeights.setEnabled(False)
    

if __name__ == '__main__':
    
    # Create the GUI application
    app = QtGui.QApplication(sys.argv)
    
    # Instantiate the main window
    dmw = MainWindow()
    
    # Show it
    dmw.show()
    
    # Start the Qt main loop execution, exiting from this script
    # with the same return code of Qt application
    sys.exit(app.exec_())

